---
title: "Appendix S1. Linear regression models and non-linear population dynamics"
author:
  - Jelena H. Pantel^[Laboratoire Chrono-environnement,UMR 6249 CNRS-UFC, 16 Route de Gray, 25030 Besançon cedex, France, jelena.pantel@univ-fcomte.fr]
  - Ruben J. Hermann^[University of Duisburg-Essen, Universitätsstraße 5, 45141 Essen, Germany, ruben.hermann@uni-due.de]
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::pdf_document2:
    toc: no
    fig_caption: yes
    latex_engine: xelatex
    extra_dependencies: ["float"]
  bookdown::html_document2: default
  word_document:
    reference_docx: docx_template.docx
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[L]{Author Pantel and Hermann}
- \fancyhead[R]{Detection of ecoevo dynamics}
- \usepackage{lineno}
- \linenumbers
link-citations: yes
linkcolor: blue
csl: the-american-naturalist.csl
bibliography: refs.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
```{r setup,echo=FALSE,message=FALSE}
library(Hmsc)
library(ggplot2)
library(tidyr)
library(coda)
library(patchwork)
library(jtools)
library(bayesplot)
```
```{r,echo=FALSE,message=FALSE,warning=FALSE}
# Wrap long lines
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy=TRUE,out.width="50%")
```

# One species, logistic growth
Population growth over time in a single species is first modelled using a Beverton-Holt (discrete-time, logistic) model (@Beverton1957), using an intra-specific competition coefficient for density-dependent growth (@Hart2013).

$$ N_{i,t+1} = \frac{r_i N_{i,t}}{1 + \alpha_{ii} N_{i,t}}$$
Note that in this model, the system is at equilibrium when $N_{i,t+1} = N_{i,t}$, and therefore: $$ N^* = N^*\frac{r_i}{1 + \alpha_{ii} N^*} $$

$$ 1 = \frac{r_i}{1 + \alpha_{ii} N^*} $$

$$ N^* = \frac{r_i - 1}{\alpha_{ii}} $$

## Population dynamics simulation
In the metacommunity simulation in the main text, a species resides in a site with an initial population size $N_{i,0} \sim Pois(10)$, a growth rate $r_i$ that depends on the local environmental value $E_k$ and the species trait $x_i$, and a fixed intra-specific competition coefficient of $\alpha_{ii}$ = 0.00125. We simulate population growth here:

```{r}
set.seed(42)
# Simulate initial species population growth
N1.0 <- rpois(1,10)
r1.0 <- 1.67
alpha.11 <- 0.00125
# model function
disc_log <- function(r, N0, alpha) {
    Nt1 <- (r*N0) / (1+alpha*N0)
    return(Nt1)
}
# Simulation of model for t time steps
t <- 30
N <- rep(NA, t)
N[1] <- N1.0
for (i in 2:t) {
  N[i] <- disc_log(r=r1.0, N0=N[i-1], alpha=alpha.11)
}
```
```{r figs1, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs1}Population size \\textit{N} over time \\textit{t} for a discrete-time logistic growth model, with parameters $r_i$ = 1.67, $N_{1,0}$ = 14, and $\\alpha_{11}$ = 0.00125."}
# Plot simulation: ggplot
dat <- as.data.frame(N)
dat$time <- 1:t
ggplot2::ggplot(dat, aes(time, N)) + geom_point() + geom_hline(yintercept = ((r1.0 - 1)/alpha.11),
    linetype = "dashed", color = "gray")
```

## Linear statistical model

We fit the population time series data to a first-order auto-regressive model to predict $N_{t+1}$ as a function of $N_t$, and compare that to a linear regression:

$$ N_{t+1} = \beta_0 + \beta_1 N_t + \epsilon_t $$
```{r,warning=FALSE}
# Fit the model
m.1.ar <- arima(x = log(N), order = c(1,0,0), include.mean = T, method="CSS")
m.1.lm <- lm(log(dat$N[2:t]) ~ log(dat$N[1:(t-1)]))
#plotting the series along with the fitted values
m.1.ar.fit <- log(N) - residuals(m.1.ar)
m.1.lm.fit <- log(dat$N[2:t]) - m.1.lm$resid
dat$ar1.fit <- m.1.ar.fit
dat$lm.fit <- NA
dat$lm.fit[2:t] <- m.1.lm.fit
```
```{r figs2, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs2}Population size over time (black line) with fitted values from a first-order autoregressive model (red dashed line).",warning=FALSE}
colors <- c("data" = "black", "AR1 fit" = "gray", "lm fit"="orange")
ggplot(data=dat,aes(x=time)) +
  geom_point(aes(y=log(N),color="data")) +
  geom_point(aes(y=ar1.fit, color = "AR1 fit"), alpha=0.5) +
  geom_point(aes(y=lm.fit, color = "lm fit"), alpha=0.5) +
  geom_line(aes(y=log(N), color="data"), linewidth=.4) +
  geom_line(aes(y=ar1.fit, color = "AR1 fit"), alpha=0.5, linewidth=.4) +
  geom_line(aes(y=lm.fit, color = "lm fit"), alpha=0.5, linewidth=.4) +
  theme_bw() +
  xlab("time") +
  ylab("N") +
  labs(color="Legend") +
  scale_color_manual(values = colors)
```

The linear model is a good fit, and $N_{t+1}$ and $N_t$ are well-represented by a linear function:

```{r figs3, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs3}Population size (logarithm) at one time step $N_{t+1}$ as a function of log-population size in the previous time step $N_t$. "}
dN <- rep(NA, (t-1))
for (i in 1:(t-1)) {
  dN[i] <- log(N[i+1])-log(N[i])
}
d.dN <- as.data.frame(dN)
d.dN$Nt <- log(dat$N[1:(t-1)])
d.dN$Nt_plus_1 <- log(dat$N[2:t])
ggplot2::ggplot(d.dN, aes(x=Nt,y=Nt_plus_1)) + geom_point()
```

We also examine density dependence by plotting $\Delta N = N_{t+1} - N_t$ vs. $N_t$:

```{r figs4, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs4} Change in population size from one time step to the next $N_{t+1}$ as a function of $N_{t+1}$"}
d.dN <- as.data.frame(dN)
d.dN$Nt <- log(dat$N[1:(t-1)])
d.dN$Nt_plus_1 <- log(dat$N[2:t])
ggplot2::ggplot(d.dN, aes(Nt, dN)) + geom_point()
```
## Bayesian linear statistical model: HMSC
We can estimate the same model parameters using HMSC:

```{r}
# prepare data in HMSC format
Y <- as.matrix(log(dat$N[2:t]))
XData <- data.frame(x=log(dat$N[1:(t-1)]))
m.1.hmsc <- Hmsc(Y=Y,XData=XData,XFormula=~x)
# Bayesian model parameters
nChains <- 2
thin <- 5
samples <- 1000
transient <- 500*thin
verbose <- 500*thin
# sample MCMC
m.1.sample <- sampleMcmc(m.1.hmsc,thin=thin,sample=samples,transient=transient,nChains=nChains,verbose=verbose)
```

```{r}
m.post.hmsc <- convertToCodaObject(m.1.sample)
summary(m.post.hmsc$Beta)
plot(m.post.hmsc$Beta)
```

These estimates match well with those from the AR1 and linear model:

```{r}
# AR1 coefficients (recall that the intercept is the term below multipled by 1 - phi1)
m.1.ar$coef
m.1.ar$coef[2]*(1-m.1.ar$coef[1])
# linear model
summary(m.1.lm)$coefficients[1:2,1:2]
# Bayesian estimates
summary(m.post.hmsc$Beta)$statistics[1:2,1:2]
```

```{r figs5, fig.pos = "H", fig.show="hold", fig.cap = "\\label{fig:figs5} Observed (grey) and model-fit (blue) values for population size at time t (x-axis) and t+1 (y-axis).",results='hide',fig.keep='all'}
Gradient <- constructGradient(m.1.sample,focalVariable="x",ngrid=29)
predY <- predict(m.1.sample,Gradient=Gradient,expected=TRUE)
#preds <-computePredictedValues(m.1.sample)
plotGradient(m.1.sample,Gradient,pred=predY,showData=T,measure="Y",main="",xlab="N_t",ylab="predicted N_t+1")
```

```{r}
lm_dat <- data.frame(cbind(log(dat$N[2:t]),log(dat$N[1:(t-1)])))
colnames(lm_dat) <- c("Nt1","Nt")
ggplot(lm_dat,aes(Nt,Nt1)) +
  stat_summary(fun.data= mean_cl_normal) + 
  geom_smooth(method='lm')
```


## Conclusions
In this example, a first-order auto-regressive model works well, bypassing the need to estimate logistic growth parameters $r_i$ and $\alpha_{ii}$. The density-dependence dynamics ($\Delta N \sim f(N_t)$) show an overall declining trend over time. The Bayesian estimation implemented in HMSC gives good parameter estimates.

# One species, logistic growth, environmental covariate
We now consider using a linear model to analyze population growth when the species growth rate is impacted by a single environmental covariate.

## Growth depends on environment

First we add environment-dependent growth rate. The growth rate $r_i$ becomes:

$$ r_i = \hat{W}e^{-(E-x_{i,t})^2}$$

Here, $\hat{W}$ is the maximal population growth rate (set to `r r1.0` as above), $E$ is the local environmental trait optimum value, and $x_{i,t}$ is species *i* trait value at time *t*. We see that if $E = x_{i,t}$ then the growth rate is at the value $r$ = `r r1.0`. Here, we begin with $E = x_{i,t} = 0.8$, then simulate the environment $E$ value fluctuating randomly over time, and finally use a linear model to fit $E$ as a covariate.

```{r}
# Simulate initial species population growth with environment fluctuations
N1.0 <- 10
r1.0 <- 1.67
alpha.11 <- 0.00125
E.0 <- 0.8
x1.0 <- 0.8
# model function
disc_log_E <- function(r, N0, alpha, E, x) {
    Nt1 <- ((r*exp(-(E-x)^2))*N0) / (1+alpha*N0)
    return(Nt1)
}
# Simulation of model for t time steps
t <- 40
N <- rep(NA, t)
N[1] <- N1.0
E <- rep(NA, t)
E[1] <- E.0
for (i in 2:t) {
  N[i] <- disc_log_E(r=r1.0, N0=N[i-1], alpha=alpha.11, E=E[i-1], x=x1.0)
  E[i] <- E[i-1] + rnorm(1,0,.1)
}
```
```{r figs6, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs1}Population size \\textit{N} over time \\textit{t} for a discrete-time logistic growth model, with parameters $r_i$ = 1.67, $N_{1,0}$ = 14, and $\\alpha_{11}$ = 0.00125. Relationship between E and Nt is also shown."}
# Plot simulation: ggplot
dat <- as.data.frame(cbind(N,E))
dat$time <- 1:t
p1 <- ggplot2::ggplot(dat, aes(time, N)) + geom_point() + geom_hline(yintercept = ((r1.0 - 1)/alpha.11),linetype = "dashed", color = "gray")
p2 <- ggplot2::ggplot(dat, aes(time, E)) + geom_point()
p1 + p2
```

## Linear statistical model with environmental covariate

We now include environment $E$ as a covariate in the linear model:

$$ N_{t} = \beta_0 + \beta_1 N_{t-1} + \beta_2 E_{t-1}+ \epsilon_t $$

```{r,warning=FALSE}
# Fit the model
m.2.ar <- arima(x = log(N), order = c(1,0,0), include.mean = T, method="CSS", xreg=E)
m.2.lm <- lm(log(dat$N[2:t]) ~ log(dat$N[1:(t-1)]) + log(E[1:(t-1)]))
#plotting the series along with the fitted values
m.2.ar.fit <- log(N) - residuals(m.2.ar)
m.2.lm.fit <- log(dat$N[2:t]) - m.2.lm$resid
dat$ar2.fit <- m.2.ar.fit
dat$lm2.fit <- NA
dat$lm2.fit[2:t] <- m.2.lm.fit
```
```{r figs7, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs2}Population size over time (black line) with fitted values from a first-order autoregressive model (red dashed line).",warning=FALSE}
colors <- c("data" = "black", "AR1 fit" = "gray", "lm fit"="orange")
ggplot(data=dat,aes(x=time)) +
  geom_point(aes(y=log(N),color="data")) +
  geom_point(aes(y=ar2.fit, color = "AR1 fit"), alpha=0.5) +
  geom_point(aes(y=lm2.fit, color = "lm fit"), alpha=0.5) +
  geom_line(aes(y=log(N), color="data"), linewidth=.4) +
  geom_line(aes(y=ar2.fit, color = "AR1 fit"), alpha=0.5, linewidth=.4) +
  geom_line(aes(y=lm2.fit, color = "lm fit"), alpha=0.5, linewidth=.4) +
  theme_bw() +
  xlab("time") +
  ylab("N") +
  labs(color="Legend") +
  scale_color_manual(values = colors)
```

```{r figs8, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs3}Population size (logarithm) at one time step $N_{t+1}$ as a function of log-population size in the previous time step $N_t$. "}
dN <- rep(NA, (t-1))
for (i in 1:(t-1)) {
  dN[i] <- log(N[i+1])-log(N[i])
}
d.dN <- as.data.frame(dN)
d.dN$Nt <- log(dat$N[1:(t-1)])
d.dN$Nt_plus_1 <- log(dat$N[2:t])
p1 <- ggplot2::ggplot(d.dN, aes(x=Nt,y=Nt_plus_1)) + geom_point()

d.dN <- as.data.frame(dN)
d.dN$Nt <- log(dat$N[1:(t-1)])
d.dN$Nt_plus_1 <- log(dat$N[2:t])
d.dN$E <- log(dat$E[2:t])
p2 <- ggplot2::ggplot(d.dN, aes(x=E,y=Nt_plus_1)) + geom_point()
p3 <- ggplot2::ggplot(d.dN, aes(Nt, dN)) + geom_point()
p4 <- ggplot2::ggplot(d.dN, aes(E, dN)) + geom_point()

p1+p2+p3+p4
```

The linear model is a good fit when including the environmental covariate. $N_{t+1}$ and $N_t$ can still be captured by a linear relationship. However we see that the relationship between $N_{t+1}$ and $E_t$ is non-linear. This tells us that the lm is good for predictions, but not for inference (for capturing well the relationsip between the predictor and response variable). The use of linear relationships in JSDMs is discussed in [@Ingram2020], and in many applications (e.g. [@Erickson2023]) quadratic terms are used, which create bell-shaped response curves that may better match species with optimal niches (as opposed to linear, monotonically increasing relationships between population size and environmental predictors). We thus include a quadratic term for $E_t$ to provide a better fit to the data.

```{r}
df <- data.frame(cbind(log(dat$N[2:t]),log(dat$N[1:(t-1)]),E[1:(t-1)],E[1:(t-1)]^2))
colnames(df) <- c("Nt1","Nt","E","Esq")
m.2.lm <- lm(Nt1 ~ Nt + E + Esq,data=df)
```

```{r figs9, fig.pos = "H",echo=FALSE, fig.show="hold", fig.cap = "\\label{fig:figs3}Population size (logarithm) at one time step $N_{t+1}$ as a function of log-population size in the previous time step $N_t$. "}
jtools::effect_plot(m.2.lm,pred=E,plot.points = TRUE)
ggplot(data = df, aes(x = E, y = Nt1)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2))
```

## Bayesian linear statistical model: HMSC
We can estimate the same model parameters using HMSC:

```{r}
# prepare data in HMSC format
Y <- as.matrix(log(dat$N[2:t]))
XData <- df
m.2.hmsc <- Hmsc(Y=Y,XData=XData,XFormula=~Nt+E+Esq)
# Bayesian model parameters
nChains <- 2
thin <- 5
samples <- 1000
transient <- 500*thin
verbose <- 500*thin
# sample MCMC
m.2.sample <- sampleMcmc(m.2.hmsc,thin=thin,sample=samples,transient=transient,nChains=nChains,verbose=verbose)
```

```{r}
m2.post.hmsc <- convertToCodaObject(m.2.sample)
summary(m2.post.hmsc$Beta)
bayesplot::mcmc_trace(m2.post.hmsc$Beta)
bayesplot::mcmc_areas(m2.post.hmsc$Beta,area_method = c("equal height"))
```

These estimates match well with those from the AR1 and linear model:

```{r}
# AR1 coefficients (recall that the intercept is the term below multipled by 1 - phi1)
m.2.ar$coef
m.2.ar$coef[2]*(1-m.2.ar$coef[1])
# linear model
summary(m.2.lm)$coefficients[1:4,1:2]
# Bayesian estimates
summary(m2.post.hmsc$Beta)$statistics[1:4,1:2]
```

We recall that the interpretation of the coefficients in an arimaX (arima with covariates) model is difficult. They do not give the impact on $N_t$ per unit increase in X as in a regression. So we do not interpret the causation implied by the coefficient in the arimaX model. In the regression model, we can see that $E$ has a positive impact on $N_t$.


```{r figs10, fig.pos = "H", fig.show="hold", fig.cap = "\\label{fig:figs5} Observed (grey) and model-fit (blue) values for population size at time t (x-axis) and t+1 (y-axis).",results='hide',fig.keep='all'}
Gradient <- constructGradient(m.2.sample,focalVariable="E",non.focalVariables=list(Nt=list(2),Esq=list(2)),ngrid=39)
predY <- predict(m.2.sample,XData=Gradient$XDataNew,expected=TRUE)
plotGradient(m.2.sample,Gradient,pred=predY,showData=T,measure="Y",main="",xlab="E_t",ylab="predicted N_t+1")
# Can't figure out curved gradient using E and E^2
#pr <- predict(m.2.hmsc,m.2.sample,)
```

## Conclusions
In this example, the linear regression again works well to describe the impact of $E_t$ for $N_t$ when using the quadratic formulation. The arimaX model works well for fitting and subsequent prediction, but less well for inference about the impacts of $E$. From the quadratic regression terms for $E$, we correctly see that the population size is maximal at the species trait value and decreases away from that value. We will continue to use log-transformed abundance and now introduce quadratic terms for the environmental parameter.

```{r}
knitr::knit_exit()
```




# Simulate initial species population growth
N1.0 <- rpois(1,10)
r1.0 <- 1.67
alpha.11 <- 0.00125

equation becomes:

$$ N_{i,t+1} = \frac{r_i N_{i,t}}{1 + \alpha_{ii} N_{i,t}}$$




We make this not linked to then linked to growth and in each instance run a linear model to show no effect is detected or is detected as it should be. E can vary randomly, as long as it links to growth.

```{r}
# Simulate initial species population growth
N1.0 <- rpois(1,10)
r1.0 <- 1.67
alpha.11 <- 0.00125
# model function
disc_log <- function(r, N0, alpha) {
    Nt1 <- (r*N0) / (1+alpha*N0)
    return(Nt1)
}
# Simulation of model for t time steps
t <- 30
N <- rep(NA, t)
N[1] <- N1.0
for (i in 2:t) {
  N[i] <- disc_log(r=r1.0, N0=N[i-1], alpha=alpha.11)
}
```



In the metacommunity simulation in the main text, a species $i$ resides in a site $k$ with an environmental optimum trait value $E_k \sim unif(0,1)$, an initial population size $N_{i,0} \sim Pois(10)$, and an initial degree of maladaptation $\beta_{0,i} \sim Gamma(0.75,1)$. From this \(\beta_{0,i}\), the initial distance to the local patch's optimum phenotype was calculated as $d_{0,i}=\sqrt{B_{0,i}(w+P)}$ and the initial trait value for each species $x_{0,i}$ is calculated by subtracting $d_{0,i}$ from the local environmental optimum value $E_k$. Here I simulate a species that is initially suited for the environment ($d_{0,i}$)

Internal question 1 - how does the $\alpha$ version compared to the $K$ version?

```{r}
set.seed(42)
# Simulate initial species population growth
N1.0 <- rpois(1,10)
# Behind-the-scenes initial r1.0
E1 <- runif(1,0,1)
beta1.0 <- rgamma(1,0.75,1)
w <- 10
P <- 1
Wmax <- 2
What <- Wmax*sqrt(w / (P+w))
h2 <- 0
d1.0 <- sqrt(beta1.0*(w+P))
x1.0 <- E1 - d1.0
# Emergent initial r1.0
r1.0 <- What*exp( -(((w+(1-h2)*P)/(P+w))*(E1-x1.0))^2/ (2*(P+w)))
alpha.11 <- 0.00125

# model function
disc_log <- function(r, N0, alpha) {
    Nt1 <- (r*N0) / (1+alpha*N0)
    return(Nt1)
}

# Simulation of model for t time steps
N <- rep(NA, t)
N[1] <- N1.0
t <- 30
for (i in 2:t) {
  N[i] <- disc_log(r=r1.0, N0=N[i-1], alpha=alpha.11)
    N0 <- N[i]
}
# Plot simulation: ggplot
dat <- as.data.frame(N)
dat$time <- as.numeric(rownames(dat))
ggplot2::ggplot(dat, aes(time, N)) + geom_point() + geom_hline(yintercept = (1/alpha.11),
    linetype = "dashed", color = "gray")
# Additional plot: how does growth rate change with time?
range <- seq(0,800,by=0.01)
rec <- rep(NA, length(range))
for (i in 1:length(range)) {
    rec[i] <- r1.0 / (1+alpha.11*range[i])
}
plot(y=rec,x=range,ylim=c(-1,2))
```


```{r}
# Parameter values to use for simulation
r <- 1.21
K <- 1400
N0 <- 4
t <- 30
# model function
disc_log <- function(r, N0, K) {
    Nt1 <- N0 + r * N0 * (1 - N0/K)
    return(Nt1)
}
# Simulation of model for t time steps
N <- rep(NA, t)
for (i in 1:t) {
    N[i] <- disc_log(r, N0, K)
    N0 <- N[i]
}
# Plot simulation: ggplot
dat <- as.data.frame(N)
dat$time <- as.numeric(rownames(dat))
ggplot2::ggplot(dat, aes(time, N)) + geom_point() + geom_hline(yintercept = K,
    linetype = "dashed", color = "gray")
```



$$ N_{i,t+1} =\frac{\hat{W}e^ \frac{-[(\frac{w+(1-h^2)P} {P+w})(E-x_{i,t})]^2}{2(P+w)}N_{i,t}} {1 + \alpha_{ii}N_{i,t} + \sum_{j \neq i}^{S} \alpha_{ij}N_{j,t}} $$

```{r}

```



## Generating the data frames
For the diagnosis first need to convert the chains into a coda object and extract the effective sample size (ESS), which denotes how many MCMC iteration were independent (e.g. having no autocorrelation) from previous iterations, and  potential scale reduction factors (PSRF), which describe how well the MCMC chains converged around a value and if the two chains differ from each other. Therefore a high value for ESS (close to the number of actual iterations multiplied by the number of chains) is preferable and a PSRF value of 1 represents both chains converging on the same mean.
Note we do not check the predictive and explanatory power of the model, as we have a perfect data set by the time series data of the simulations, which leads to $R^2$ > .98.
```{r eval=FALSE}
load("../../output/h_01_d_minus3_hmsc_v01.RData")
m.post <- convertToCodaObject(m.1)
ess.beta<- effectiveSize(m.post$Beta)
psrf.beta <- gelman.diag(m.post$Beta, multivariate=FALSE)$psrf
```

# References





